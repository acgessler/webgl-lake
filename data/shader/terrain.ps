

/* medea.js - Open Source, High-Performance 3D Engine based on WebGL.
 *
 * (c) 2011-2013, Alexander C. Gessler
 *  https://github.com/acgessler/medea.js
 *
 * Made available under the terms and conditions of a 3-clause BSD license.
 *
 */

#include <remote:mcore/shaders/core.psh>
#include <remote:mcore/shaders/lighting.psh>

uniform vec3 LIGHT_D0_DIR;

uniform sampler2D coarse_normal_texture;

uniform sampler2D ground_texture;
uniform sampler2D ground_normal_texture;

uniform sampler2D stone_texture;
uniform sampler2D stone_normal_texture;

uniform sampler2D grass_texture;
uniform sampler2D snow_texture;

#ifdef TERRAIN_SPECULAR
uniform vec4 spec_color_shininess;
#endif

uniform vec4 terrain_uv_offset_scale;
uniform float inv_terrain_map_dim;
uniform float uv_scale;

const float kDETAIL_NORMAL_STRENGTH = 0.6;
const float kSPECULAR_STRENGTH = 0.2;
const float kCOARSE_NORMAL_SCALE = 0.18;
const float kALL_SNOW_HEIGHT = 0.60;
const float kSNOW_BEGIN = 0.55;

void main()
{
	vec2 uv = FetchTexCoord();

	// Fetch normal, height and occlusion from RGBA normal map
	vec4 nor_occ = texture2D(coarse_normal_texture,
		inv_terrain_map_dim * (terrain_uv_offset_scale.xy + uv * terrain_uv_offset_scale.zw)
	);

	// The blue channel of the normal map contains a perlin noise
	float noise = nor_occ.b;
	nor_occ.b = 1.0;

	uv *= uv_scale;

	// Take the normal from rg, skew the angle a bit
	// Note: for an unrotated terrain tile, tangent and world space
	// is the same, which greatly simplifies all tangent space
	// calculations we do.
	vec3 N = (nor_occ.rbg-0.5) * vec3(2.0, 2.0 * kCOARSE_NORMAL_SCALE, 2.0);
	N = normalize(N);

	// Derive the blending between ground base and rock base from the angle
	float rock_base_blend = N.g + 0.2;

	// Mix in the normal deltas from both maps.
	// This now is an approximation to properly blending normals
	// which is more than just an addition.
	vec3 nor_base = texture2D(ground_normal_texture, uv).rgb;
	vec3 nor_rock = texture2D(stone_normal_texture, uv).rgb;
	N += (mix(nor_rock, nor_base, rock_base_blend) - 0.5).rbg * 2.0 *
		kDETAIL_NORMAL_STRENGTH;
	N = normalize(N);

	// Diffuse contribution: simple lambert against sun direction
	float diffuse = ComputeLambertDiffuseCoeff(LIGHT_D0_DIR, N);

	// Apply ambient occlusion
	diffuse = diffuse * nor_occ.a;

	vec3 eye = FetchVec4(eye_height).xyz;
#ifdef TERRAIN_SPECULAR
	// Specular contribution: simple blinn with self-shadowing
	float specular = ComputeBlinnSpecularCoeff(
		eye,
		N,
		LIGHT_D0_DIR,
		spec_color_shininess.a
	) * kSPECULAR_STRENGTH;
	specular *= clamp(diffuse * 4.0, 0.0, 1.0);
#endif

	// Get the diffuse base color by blending the color textures
	vec3 tex_base = texture2D(ground_texture, uv).rgb;
	vec3 tex_rock = texture2D(stone_texture, uv).rgb;
	tex_base *= tex_base; // Gamma
	tex_rock *= tex_rock; // Gamma
	vec3 tex = mix(tex_rock, tex_base, rock_base_blend);

	float height = FetchVec4(eye_height).w;
	if (height <= kSNOW_BEGIN) {
		vec3 tex_green = texture2D(grass_texture, uv).rgb;
		tex_green *= tex_green; // Gamma

		float d = max(0.0, 1.0 - rock_base_blend * rock_base_blend * noise);
		tex = mix(tex_green, tex, d);
	}
	else {
		vec3 tex_snow = texture2D(snow_texture, uv).rgb;
		tex_snow *= tex_snow; // Gamma

		float snow_transition = (kALL_SNOW_HEIGHT - height) / (kALL_SNOW_HEIGHT - kSNOW_BEGIN);
		tex = mix(tex_snow, tex, min(1.0, max(-0.5, snow_transition + rock_base_blend * 0.5)));
	}


	// Simple fog
	vec3 color = tex * diffuse
#ifdef TERRAIN_SPECULAR
	+ spec_color_shininess.rgb * specular;
#endif
	;
	vec3 fog_color = vec3(0.4,0.55,0.85);
	float eye_height = eye.y / 300.0;
	eye.y = 0.0;
	float distance = clamp((dot(eye, eye) - 500000.0) / (2000000.0 * eye_height), 0.0, 1.0);

	// Assemble, Fog, Gamma
    gl_FragColor.a = 1.0;
	gl_FragColor.rgb = sqrt(mix(color, fog_color, clamp(distance, 0.0, 1.0)));
}

